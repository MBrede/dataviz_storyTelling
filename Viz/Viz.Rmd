---
title: "Visualisierung"
output:
  # pdf_document:
  #   includes:
  #     in_header: header_doc.tex
  html_document:
    css: styles.css
    fig_caption: true
    toc: true
---

```{r setup, include=FALSE}
# test
library(knitr)
library(kableExtra)
library(tidyverse)

opts_chunk$set(echo = TRUE,fig.align = 'center')

theme_set(theme_light())
```

## Viz 1

Vergleich Schweden Deutschland - Indizienden oder positiv-Tests oder relative Fallzahlen oder alles (timeseries) [Inzidenz- und Testdaten](https://covid.ourworldindata.org/data/owid-covid-data.csv)

## Attaining the data
For attaining the covid-19 policy data we read the data from the github of the
[Coronavirus Government Response Tracker Project](https://www.bsg.ox.ac.uk/research/research-projects/coronavirus-government-response-tracker#data).

```{r, cache=TRUE}
# read policies csv-file
policies <- read.csv('https://raw.githubusercontent.com/OxCGRT/covid-policy-tracker/master/data/OxCGRT_latest.csv')
```

After reading the data, we take a glimpse on the data.
```{r}
# take a glimpse of the policy data
glimpse(policies)
```
For the meanings of specific policies take a look on the [Codebook](https://github.com/OxCGRT/covid-policy-tracker/blob/master/documentation/codebook.md) of the project.


The data set gets filtered for german policies and the relevant policies get selected.

```{r}
# a function for pre filtering

filtering <- function(country_name, policy_filter) {
   policies_ger <- policies %>%
                filter(CountryName==country_name) %>% # filter policies by germany
                select(policy_filter) %>% # select policies of interest
                mutate(Date=as.Date(as.character(Date),
                                    format = "%Y%m%d")) %>% # change date format
                na.omit() %>% # remove rows with na entries
                arrange(Date) # order rows by date
}
```

```{r}
# a function to build start and stop labels for the equivalent policy
build_start_stop_labels <- function(policies, policy, label){
  # get selected policy data
  selected_policy <- policies %>%
                      select(Date, policy)

  # build bit-mask for policy changes
  bit_mask <- selected_policy[,policy] -  lag(selected_policy[,policy], n = 1) != 0

  # set last entry true (is na because of lag)
  bit_mask[is.na(bit_mask)] <- TRUE
  
  # initialize start and stop list
  start <- c()
  stop <- c()

  # initialize a state variable for tracking start position
  start_state <- TRUE

  # iterate through rows for finding start and stop positions
  for(row in 1:length(bit_mask)){
    # check whether it's a stop position
    if(bit_mask[row] & !start_state){
      stop <- c(stop, row-1)
      start_state <- TRUE
    }
    # check whether it's a start position
    if(bit_mask[row] & start_state){
      start <- c(start, row)
      start_state <- FALSE
    }
  }

  # add last row as stop
  stop <- c(stop, row)
  
  # retrieve start and stop dates from the data set
  start_date <- selected_policy[start, 'Date']
  stop_date <- selected_policy[stop, 'Date']
  # retrieve event number from the data set
  events <- selected_policy[start, policy]
  
  # return dataframe with start/stop dates for the polcies
  return(data.frame(event = events, start = start_date, end = stop_date,
                    group = label))
}

```

```{r}

# set germany as country
country_name <- 'Germany'

# set filter for columns of interest
policy_filter <- c('CountryCode', 'Date', 'C8_International.travel.controls',
  'C6_Stay.at.home.requirements', 'C4_Restrictions.on.gatherings')

# retrieve policy data
policies_ger <- filtering(country_name, policy_filter)

# process policy data to a timeline
timeline_data <- rbind(
                       build_start_stop_labels(policies_ger,
                                               'C8_International.travel.controls',
                                               'International Travel Controls'),
                       build_start_stop_labels(policies_ger,
                                               'C6_Stay.at.home.requirements',
                                               'Stay at Home'),
                       build_start_stop_labels(policies_ger,
                                               'C4_Restrictions.on.gatherings',
                                               'Gathering Restrictions')
                       )

# load vistime
library(vistime)

# plot timeline
vistime(timeline_data)

```

```{r}

# set sweden as country
country_name <- 'Sweden'

# set filter for columns of interest
policy_filter <- c('CountryCode', 'Date', 'C8_International.travel.controls',
  'C6_Stay.at.home.requirements', 'C4_Restrictions.on.gatherings')

# retrieve policy data
policies_se <- filtering(country_name, policy_filter)

# process policy data to a timeline
timeline_data <- rbind(
                       build_start_stop_labels(policies_se,
                                               'C8_International.travel.controls',
                                               'International Travel Controls'),
                       build_start_stop_labels(policies_se,
                                               'C6_Stay.at.home.requirements',
                                               'Stay at Home'),
                       build_start_stop_labels(policies_se,
                                               'C4_Restrictions.on.gatherings',
                                               'Gathering Restrictions')
                       )

# load vistime
library(vistime)

# plot timeline
vistime(timeline_data)

```


```{r, cache=TRUE}
# retrieve covid data from covid.ourworldindata.org git repository
covid_data <- read.csv('https://covid.ourworldindata.org/data/owid-covid-data.csv')

# filter for datasets of interest
covid_data %<>% filter(location=='Germany' | location=='Sweden') %>% # filter policies by germany
                select(location, date,
                       new_cases_smoothed_per_million) %>% # select columns of interest
                na.omit() %>% # remove rows with na entries              
                mutate(date=as.Date(as.character(date),
                                    format = "%Y-%m-%d")) # change date format

```

```{r}
# retrieve german data from dataframe and plot
covid_data %>% filter(location=='Germany') %>% ggplot(aes(x = date,
                                                          y = new_cases_smoothed_per_million)) +
  geom_area(color='black', fill = 'red', alpha = 0.5) +
  labs(x = 'Date', y = 'Smoothed New Cases per Million')

```

```{r}
# retrieve swedish data from dataframe and plot
covid_data %>% filter(location=='Sweden') %>% ggplot(aes(x = date,
                                                          y = new_cases_smoothed_per_million)) +
  geom_area(color='black', fill = 'red', alpha = 0.5) +
  labs(x = 'Date', y = 'Smoothed New Cases per Million')

```
```{r}
# retrieve swedish data from dataframe and plot
library(magrittr)
covid_data %<>% filter(location=='Sweden'||location=='Germany')

covid_data %>% filter(location=='Germany') %>%
               rename('new_cases_smoothed_per_million_germany' =
                      'new_cases_smoothed_per_million') -> covid_data_de

covid_data %>% filter(location=='Sweden') %>%
               rename('new_cases_smoothed_per_million_sweden' = 
                      'new_cases_smoothed_per_million') -> covid_data_se


# pivoz wider

joined_covid_data <- full_join(covid_data_de, covid_data_se, by = 'date')  
  
ggplot(aes(x = date, y = new_cases_smoothed_per_million)) +
  geom_area(color='black', fill = 'red', alpha = 0.5) +
  labs(x = 'Date', y = 'Smoothed New Cases per Million')




```


Zeitreihen in Facets, [Massnahmen](https://raw.githubusercontent.com/OxCGRT/covid-policy-tracker/master/data/OxCGRT_latest.csv) 

## Viz 2

Zeitreihen Zeitungsartikel 
```{r}
sentiment_time_series <- read_rds('data/documents_with_sentiments.rds') %>% 
  mutate(publish_date = lubridate::as_date(as.Date(publish_date))) %>% 
  group_by(country, publish_date) %>% 
  summarise(sentiment = mean(m_sentiment),
            `number of articles` = n()) %>% 
  ungroup() %>%
  group_by(country) %>% 
  group_split() %>% 
  map_dfr(~mutate(.,across(where(is.numeric),
                           ~stats::filter(.,filter = dnorm(seq(-2,2,length.out = 7))/sum(dnorm(seq(-2,2,length.out = 7)))),
                           .names = 'filter_{.col}'))) %>% 
  rename('original_number of articles' = 'number of articles', 'original_sentiment' = sentiment) %>% 
  pivot_longer(cols = where(is.numeric), values_to = 'value', names_to = c('quality','indicator'),names_sep = '_') %>% 
  pivot_wider(names_from = quality,
              values_from = value)

sentiment_time_series %>% 
  ggplot(aes(x = publish_date, y = original)) +
  geom_point(color = 'blue', alpha = .25) +
  geom_line(aes(y = filter), color = 'blue') +
  facet_wrap(indicator ~ country,scales = 'free')
  
```



## Viz 3

Wordclouds f√ºr interessante Zeitpunkte
```{r}
library(tmap)
library(sf)

data(World, package = "tmap")  # load data from tmap package
world <- World                 # rename

se <- world %>% filter(name == "Sweden") %>% pull(geometry)
plot(se, col='black')

library(ggwordcloud)
#> Loading required package: ggplot2
data("love_words_small")
data("love_words")

set.seed(42)
ggplot(love_words_small, aes(label = word, size = speakers)) +
  geom_text_wordcloud_area(
    mask = png::readPNG("./rplot.png"),
    rm_outside = TRUE
  ) +
  scale_size_area(max_size = 18) +
  theme_minimal()

```
